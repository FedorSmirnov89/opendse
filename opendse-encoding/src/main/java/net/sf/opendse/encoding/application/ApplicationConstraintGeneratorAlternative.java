package net.sf.opendse.encoding.application;

import java.util.HashMap;
import java.util.HashSet;
import java.util.Map;
import java.util.Set;

import org.opt4j.satdecoding.Constraint;

import net.sf.opendse.encoding.constraints.Constraints;
import net.sf.opendse.encoding.variables.ApplicationAlternative;
import net.sf.opendse.encoding.variables.ApplicationVariable;
import net.sf.opendse.encoding.variables.DTT;
import net.sf.opendse.encoding.variables.T;
import net.sf.opendse.encoding.variables.Variable;
import net.sf.opendse.encoding.variables.Variables;
import net.sf.opendse.model.Application;
import net.sf.opendse.model.Element;
import net.sf.opendse.model.properties.ApplicationElementPropertyService;

/**
 * The {@link ApplicationConstraintGeneratorAlternative} is used when the
 * designer describes the application by providing several alternative
 * {@link Application} graph representations for the function(s) in the
 * application. The {@link Constraint}s generated by the
 * {@link ApplicationConstraintGeneratorAlternative} then make sure that in each
 * valid implementation, exactly one alternative is activated for each function.
 * 
 * @author Fedor Smirnov
 *
 */
public class ApplicationConstraintGeneratorAlternative implements ApplicationConstraintGenerator {

	/**
	 * Returns the {@link Constraint}s that make sure that in each valid
	 * implementation, exactly one alternative is activated for each function.
	 * 
	 * @param applicationVariables
	 *            the {@link ApplicationVariable}s with the alternative
	 *            activation mode from the {@link Application} provided by
	 *            the designer
	 * @return the {@link Constraint}s that make sure that in each valid
	 *         implementation, exactly one alternative is activated for each
	 *         function
	 */
	@Override
	public Set<Constraint> toConstraints(Set<ApplicationVariable> applicationVariables) {
		Set<Constraint> result = new HashSet<Constraint>();
		Map<String, Set<String>> functionToIdsMap = new HashMap<String, Set<String>>();
		fillFunctionToIdsMap(functionToIdsMap, applicationVariables);
		for (String functionName : functionToIdsMap.keySet()) {
			// states that for each function, exactly one alternative is active
			Set<ApplicationAlternative> altVariables = new HashSet<ApplicationAlternative>();
			for (String altId : functionToIdsMap.get(functionName)) {
				altVariables.add(Variables.varApplicationAlternative(functionName, altId));
			}
			result.add(Constraints.generatePickExactlyNConstraint(altVariables, 1));
		}
		for (ApplicationVariable applVar : applicationVariables) {
			// states that each application variable is activated or deactivated together
			// with its application alternative variable
			ApplicationAlternative altVar = getApplicationAlternativeVariable(applVar);
			result.add(Constraints.generateEqualityConstraint(altVar, (Variable) applVar));
		}
		return result;
	}

	/**
	 * Fills the map that maps the names of the application functions onto sets of
	 * their alternative.
	 * 
	 * @param functionToIdsMap
	 *            the map that maps the {@link String} name of an application
	 *            function that has alternative implementations onto a set of
	 *            {@link String} names of the possible alternative implementations
	 *            of the particular function
	 * @param applicationVariables
	 *            the set of {@link ApplicationVariable}s of the application
	 *            {@link Element}s with the ALTERNATIVE activation mode
	 */
	protected void fillFunctionToIdsMap(Map<String, Set<String>> functionToIdsMap,
			Set<ApplicationVariable> applicationVariables) {
		for (ApplicationVariable applVar : applicationVariables) {
			ApplicationAlternative altVar = getApplicationAlternativeVariable(applVar);
			String functionName = altVar.getFunctionName();
			String alternativeId = altVar.getFunctionId();
			if (!functionToIdsMap.containsKey(functionName)) {
				functionToIdsMap.put(functionName, new HashSet<String>());
			}
			functionToIdsMap.get(functionName).add(alternativeId);
		}
	}

	/**
	 * Returns the {@link ApplicationAlternative} {@link Variable} that dictates the
	 * activation of the given {@link ApplicationVariable}.
	 * 
	 * @param applVariable
	 *            the {@link ApplicationVariable} in question
	 * @return the {@link ApplicationAlternative} {@link Variable} that dictates the
	 *         activation of the given {@link ApplicationVariable}
	 */
	protected ApplicationAlternative getApplicationAlternativeVariable(ApplicationVariable applVariable) {
		Element element = null;
		if (applVariable instanceof T) {
			T tVar = (T) applVariable;
			element = tVar.getTask();
		}
		if (applVariable instanceof DTT) {
			DTT dttVar = (DTT) applVariable;
			element = dttVar.getDependency();
		}
		String functionName = ApplicationElementPropertyService.getAlternativeFunction(element);
		String alternativeId = ApplicationElementPropertyService.getAlternativeId(element);
		return Variables.varApplicationAlternative(functionName, alternativeId);
	}
}
